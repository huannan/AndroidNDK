### C语言里面的内存划分

1. 栈区（栈内存，存放局部变量，自动分配和释放，里面函数的参数，方法里面的临时变量）
2. 堆区（动态内存分配，C语言里面由程序员手动分配），最大值为操作系统的80%
3. 全局区（静态区）
4. 常量区（字符串）
5. 程序代码区

### 静态与动态内存分配

1. 在程序运行过程中，动态指定需要使用的内存大小，手动释放，释放之后这些内存还可以被重新使用。
2. 静态内存分配，分配内存大小的是固定，问题： 

    1. 很容易超出栈内存的最大值
    2. 为了防止内存不够用会开辟更多的内存，容易浪费内存。

### 栈溢出

```c
void main(){
	// 下面的代码会导致栈溢出
	// 属于静态内存分配，分配到栈里面，Window里面每一个应用栈大概是2M，大小确定。与操作系统有关。
	int a [1024 * 1024 * 10 * 4];
}
```

### 动态内存分配与释放

```c
// 堆内存里面动态开辟40M的内存空间
// 参数：字节 -> KB -> M -> 10M -> 40M
int* p1 = (int*)malloc(1024*1024*10*sizeof(int));

//释放
free(p1);
```

### 通过动态内存分配来动态指定数组的大小

```c
// 手动输入数组大小
int len;
len = scanf("%d" , &len);

int* arr = (int*)malloc(len * sizeof(int));
// 另外一种方法
// int* arr = (int*)calloc(len , sizeof(int));

// 指针arr是数组的首地址，arr就是数组的名称
// 给数组元素赋值（使用这一块刚刚开辟出来的内存区域）
int i = 0;
for (; i < len - 1; i++){
	arr[i] = rand() % 100;
	printf("%d,%#x\n", arr[i], &arr[i]);
}

free(arr);
```

### 重新分配realloc

重新分配内存的两种情况：

 1. 缩小，缩小的那一部分数据会丢失
 2. 扩大，需要注意内存必须是连续的，因此扩大又要分以下几种特殊情况：

     1. 如果当前内存段后面有需要的内存空间，直接扩展这段内存空间，realloc返回原指针
     2. 如果当前内存段后面的空闲字节不够，那么就使用堆中的第一个能够满足这一要求的内存块，将目前的数据复制到新的位置，并将原来的数据库释放掉，返回新的内存地址
     3. 如果申请失败，返回NULL，原来的指针仍然有效

代码示例：

```c
// 原来分配的内存
int* arr = (int*)malloc(10 * sizeof(int));
int addLen = 5;
// 用realloc来扩大内存
// 参数：1.原来内存的指针 2.内存扩大之后的总大小
int* p2 = (int*)realloc(arr, (len + addLen) * sizeof(int) );

// 重新给新的数组赋值
i = 0;
for (; i < len + addLen; i++){
	p2[i] = rand() % 200;
	printf("%d,%#x\n", p2[i], &p2[i]);
}
```

### 释放内存的细节问题

1. 不能多次释放（否则会产生中断）
2. 释放完之后（指针仍然有值），给指针置NULL，标志释放完成
3. 注意内存泄漏（p重新赋值之后，再free，并没有真正释放内存（之前的内存））

#### 安全释放的例子

```c
if (p2 != NULL)
{
	free(p2);
	p2 = NULL;
}
```

#### 内存泄漏的例子

```c
void main(){
   //分配40M
   int* p = (int*)malloc(1024*1024*40);

   // 下一次分配之前，如果不释放，会造成40M的内存泄漏
   // free(p);
   // p = NULL;

   // 分配80M
   p = (int*)malloc(1024*1024*80);
   free(p);

   system("pause");
}
```

